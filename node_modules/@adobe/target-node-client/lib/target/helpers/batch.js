/** ***********************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2018 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ************************************************************************* */
const _ = require("lodash");
const { createTargetCookie } = require("../target-cookies");
const { extractClusterFromEdgeHost } = require("../utils");
const { copyObjectByFields, isEmptyObject } = require("../../common/utils");
const {
  BATCH_REQUEST_AAM_PARAMS_KEY,
  BATCH_MBOX_RESPONSE_FIELDS,
  BATCH_MBOX_REQUIRED_FIELDS,
  BATCH_MBOXES_RESPONSE_KEY,
  BATCH_REQUEST_ALLOWED_FIELDS,
  BATCH_RESPONSE_ALLOWED_FIELDS,
  BATCH_REQUEST_SDID_KEY,
  BATCH_VISITOR_ID_KEY,
  DEVICE_ID_MAX_AGE,
  DEVICE_ID_KEY,
  EDGE_HOST_KEY,
  LOCATION_HINT_MAX_AGE,
  MBOX_PARAMETERS,
  MBOX_PARAMS_TO_AAM_PARAMS,
  MCSDID_PARAMETER,
  SESSION_ID_MAX_AGE,
  TRACE_KEY,
  VISITOR_ID_KEY,
  HASH,
  PIPE,
  AUTH_STATE
} = require("../constants");
const {
  DEVICE_ID_COOKIE,
  LOCATION_HINT_COOKIE,
  SESSION_ID_COOKIE
} = require("../target-cookies");

function createConsumerId(payload) {
  return payload.mboxes.map(v => `${v.mbox}${HASH}${v.indexId}`).join(PIPE);
}

function convertCustomerIds(customerIds) {
  return _.keys(customerIds).reduce((acc, key) => {
    const item = {};
    const value = customerIds[key];

    if (!_.isNil(key)) {
      item.integrationCode = key;
    }

    if (!_.isNil(value.id)) {
      item.id = value.id;
    }

    if (!_.isNil(value.authState) && AUTH_STATE[value.authState]) {
      item.authenticatedState = AUTH_STATE[value.authState];
    }

    acc.push(item);

    return acc;
  }, []);
}

function createVisitorBatchPayload(
  deviceId,
  targetPayload,
  visitorPayload,
  customerIds
) {
  const result = {};
  const visitorId = Object.assign({}, targetPayload[BATCH_VISITOR_ID_KEY]);
  const marketingCloudVisitorId = visitorPayload[VISITOR_ID_KEY];

  if (deviceId) {
    visitorId[DEVICE_ID_KEY] = deviceId;
  }

  if (marketingCloudVisitorId) {
    visitorId[VISITOR_ID_KEY] = marketingCloudVisitorId;
  }

  if (!isEmptyObject(customerIds)) {
    visitorId.customerIds = convertCustomerIds(customerIds);
  }

  if (!isEmptyObject(visitorId)) {
    result[BATCH_VISITOR_ID_KEY] = visitorId;
  }

  return result;
}

function adaptBatchMboxResponse(mboxResponse) {
  return copyObjectByFields(BATCH_MBOX_RESPONSE_FIELDS, mboxResponse);
}

function cleanTargetResponse(response) {
  return copyObjectByFields(BATCH_RESPONSE_ALLOWED_FIELDS, response);
}

function processBatchResponse(sessionId, requestCluster, response) {
  const result = {};
  const content = cleanTargetResponse(response);
  const deviceId = response.id[DEVICE_ID_KEY];
  const mboxes = response[BATCH_MBOXES_RESPONSE_KEY];
  const trace = response[TRACE_KEY];
  const nowInSeconds = Math.ceil(Date.now() / 1000);
  const cookies = [];
  const cluster =
    requestCluster || extractClusterFromEdgeHost(response[EDGE_HOST_KEY]);

  if (sessionId) {
    cookies.push({
      name: SESSION_ID_COOKIE,
      value: sessionId,
      expires: nowInSeconds + SESSION_ID_MAX_AGE
    });
  }

  if (deviceId) {
    cookies.push({
      name: DEVICE_ID_COOKIE,
      value: deviceId,
      expires: nowInSeconds + DEVICE_ID_MAX_AGE
    });
  }

  if (mboxes && mboxes.length > 0) {
    content.mboxResponses = mboxes.map(adaptBatchMboxResponse);
  }

  if (trace) {
    content.trace = trace;
  }

  const targetCookie = createTargetCookie(cookies);

  if (targetCookie) {
    result.targetCookie = targetCookie;
  }

  if (cluster) {
    result.targetLocationHintCookie = {
      name: LOCATION_HINT_COOKIE,
      value: cluster,
      maxAge: LOCATION_HINT_MAX_AGE
    };
  }

  result.content = content;

  return result;
}

function cleanTargetBatchPayload(payload) {
  return copyObjectByFields(BATCH_REQUEST_ALLOWED_FIELDS, payload);
}

function createTraceBatchPayload(traceToken) {
  const result = {};

  if (traceToken) {
    result.trace = {
      enabled: true
    };
  }

  return result;
}

function validateBatchMboxRequiredFields(mbox) {
  /* eslint-disable-next-line no-restricted-syntax */
  for (const [field, errorMessage] of BATCH_MBOX_REQUIRED_FIELDS) {
    if (_.isUndefined(mbox[field])) {
      return new Error(errorMessage);
    }
  }
  return null;
}

function createAamPayload(visitorPayload) {
  const result = {};

  if (!visitorPayload[MBOX_PARAMETERS]) {
    return result;
  }

  /* eslint-disable-next-line no-restricted-syntax */
  const aamParams = Object.keys(MBOX_PARAMS_TO_AAM_PARAMS).reduce(
    (params, mboxParam) => {
      const aamParam = MBOX_PARAMS_TO_AAM_PARAMS[mboxParam];
      const paramValue = visitorPayload[MBOX_PARAMETERS][mboxParam];
      const paramResult = {};

      if (!_.isUndefined(paramValue)) {
        paramResult[aamParam] = paramValue;
      }

      return Object.assign({}, params, paramResult);
    },
    {}
  );

  if (!isEmptyObject(aamParams)) {
    result[BATCH_REQUEST_AAM_PARAMS_KEY] = aamParams;
  }

  return result;
}

function createBatchRequest(uri, headers, qs, timeout, body, visitorPayload) {
  const json = Object.assign({}, body);

  if (
    visitorPayload[MBOX_PARAMETERS] &&
    visitorPayload[MBOX_PARAMETERS][MCSDID_PARAMETER]
  ) {
    json[BATCH_REQUEST_SDID_KEY] =
      visitorPayload[MBOX_PARAMETERS][MCSDID_PARAMETER];
  }

  return {
    uri,
    headers,
    qs,
    timeout,
    json
  };
}

module.exports = {
  createConsumerId,
  processBatchResponse,
  cleanTargetBatchPayload,
  createVisitorBatchPayload,
  createBatchRequest,
  createAamPayload,
  adaptBatchMboxResponse,
  createTraceBatchPayload,
  validateBatchMboxRequiredFields
};
