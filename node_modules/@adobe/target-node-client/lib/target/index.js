/** ***********************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 *  Copyright 2017 Adobe Systems Incorporated
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Adobe Systems Incorporated and its suppliers,
 * if any.  The intellectual and technical concepts contained
 * herein are proprietary to Adobe Systems Incorporated and its
 * suppliers and are protected by all applicable intellectual property
 * laws, including trade secret and copyright laws.
 * Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained
 * from Adobe Systems Incorporated.
 ************************************************************************* */

const request = require("request");
const Messages = require("../common/messages");
const {
  createConsumerId,
  processBatchResponse,
  validateBatchMboxRequiredFields,
  cleanTargetBatchPayload,
  createAamPayload,
  createTraceBatchPayload,
  createVisitorBatchPayload,
  createBatchRequest
} = require("./helpers/batch");
const {
  createTraceSinglePayload,
  createSingleRequest,
  processSingleResponse
} = require("./helpers/single");
const { throwError } = require("../common/utils");
const {
  parseCookies,
  TARGET_COOKIE,
  LOCATION_HINT_COOKIE
} = require("./target-cookies");
const {
  createHeaders,
  getCluster,
  getDeviceId,
  getSessionId,
  getTargetHost,
  createVisitorPayload
} = require("./utils");
const {
  MBOX_ENDPOINT,
  BATCH_MBOX_ENDPOINT,
  BATCH_SESSION_ID_HEADER_KEY,
  PROTOCOL,
  SECURE_PROTOCOL,
  TIMEOUT,
  DEVICE_ID_KEY,
  AT_PREFIX,
  REQUEST_SENT,
  RESPONSE_RECEIVED
} = require("./constants");

function executeRequest(http, targetRequest) {
  return new Promise((resolve, reject) => {
    http.post(targetRequest, (error, response, body) => {
      if (error) {
        reject(error);
        return;
      }

      if (response.statusCode !== 200) {
        reject(body);
        return;
      }

      resolve(body);
    });
  });
}

/**
 * The Target class
 * @param {Object} options
 * @param {Object} options.visitor
 * @param {String} options.targetCookie, optional
 * @param {String} options.targetLocationHintCookie, optional
 * @param {Object} options.http, optional mostly used for testing
 * @param {Object} options.config
 * @param {Object} options.logger
 * @param {String} options.config.client
 * @param {String} options.config.host
 * @param {Boolean} options.config.secure
 * @param {Number} options.config.timeout
 */
function Target(options) {
  if (!options) {
    throwError(Messages.OPTIONS_REQUIRED);
  }

  const http = options.http || request;
  const { visitor } = options;

  if (!visitor) {
    throwError(Messages.VISITOR_REQUIRED);
  }

  const { config } = options;

  if (!config) {
    throwError(Messages.CONFIG_REQUIRED);
  }

  const { client } = config;

  if (!client) {
    throwError(Messages.CLIENT_REQUIRED);
  }

  const { logger } = options;

  if (!logger) {
    throwError(Messages.LOGGER_REQUIRED);
  }

  const { customerIds } = options;
  const secure = config.secure === undefined ? true : Boolean(config.secure);
  const { serverDomain } = config;
  const protocol = secure ? SECURE_PROTOCOL : PROTOCOL;
  const timeout = config.timeout || Number(TIMEOUT);
  const edgeCluster = options.targetLocationHintCookie;
  const cookies = parseCookies(options.targetCookie);

  this.executeSingleMbox = (userSessionId, payload, traceToken) => {
    if (!payload) {
      return Promise.reject(new Error(Messages.REQUEST_REQUIRED));
    }

    if (!payload.mbox) {
      return Promise.reject(new Error(Messages.MBOX_REQUIRED));
    }

    const { mbox } = payload;
    const visitorPayload = createVisitorPayload(visitor, mbox, customerIds);
    const sessionId = getSessionId(cookies, userSessionId);
    const deviceId = getDeviceId(cookies);
    const cluster = getCluster(deviceId, edgeCluster);
    const host = getTargetHost(serverDomain, cluster, client);
    const headers = createHeaders(traceToken);
    const tracePayload = createTraceSinglePayload(traceToken);
    const deviceIdPayload = { [DEVICE_ID_KEY]: deviceId || undefined };
    const uri = `${protocol}${host}${MBOX_ENDPOINT}${sessionId}`;
    const qs = { client };
    const json = Object.assign({}, deviceIdPayload, payload, tracePayload);
    const targetRequest = createSingleRequest(
      uri,
      headers,
      qs,
      timeout,
      json,
      visitorPayload
    );

    logger.log(AT_PREFIX, REQUEST_SENT, targetRequest);

    return executeRequest(http, targetRequest).then(response => {
      logger.log(AT_PREFIX, RESPONSE_RECEIVED, response);

      return processSingleResponse(cluster, response);
    });
  };

  this.executeBatchMbox = (userSessionId, payload, traceToken) => {
    if (!payload) {
      return Promise.reject(new Error(Messages.REQUEST_REQUIRED));
    }
    if (!payload.mboxes || payload.mboxes.length < 1) {
      return Promise.reject(new Error(Messages.MBOXES_REQUIRED));
    }

    /* eslint-disable-next-line no-restricted-syntax */
    for (const mbox of payload.mboxes) {
      const validationErr = validateBatchMboxRequiredFields(mbox);
      if (validationErr) {
        return Promise.reject(validationErr);
      }
    }

    const consumerId = createConsumerId(payload);
    const visitorPayload = createVisitorPayload(visitor, consumerId);
    const sessionId = getSessionId(cookies, userSessionId);
    const deviceId = getDeviceId(cookies);
    const cluster = getCluster(deviceId, edgeCluster);
    const host = getTargetHost(serverDomain, cluster, client);
    const qs = {};
    const headers = createHeaders(traceToken);
    const uri = `${protocol}${host}${BATCH_MBOX_ENDPOINT}`;
    const tracePayload = createTraceBatchPayload(traceToken);
    const targetPayload = cleanTargetBatchPayload(payload);
    const visitorBatchPayload = createVisitorBatchPayload(
      deviceId,
      targetPayload,
      visitorPayload,
      customerIds
    );
    const aamPayload = createAamPayload(visitorPayload);
    const json = Object.assign(
      { client },
      aamPayload,
      targetPayload,
      tracePayload,
      visitorBatchPayload
    );

    headers[BATCH_SESSION_ID_HEADER_KEY] = sessionId;

    const targetRequest = createBatchRequest(
      uri,
      headers,
      qs,
      timeout,
      json,
      visitorPayload
    );

    logger.log(AT_PREFIX, REQUEST_SENT, targetRequest);

    return executeRequest(http, targetRequest).then(response => {
      logger.log(AT_PREFIX, RESPONSE_RECEIVED, response);

      return processBatchResponse(sessionId, cluster, response);
    });
  };
}

Target.getCookieName = () => TARGET_COOKIE;
Target.getLocationHintCookieName = () => LOCATION_HINT_COOKIE;

module.exports = Target;
